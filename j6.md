1) Compile the two files below and run the main method in the SimpleThreadExample

```java
$ javac *.java
$ java SimpleThreadExample
```
```java
/* SimpleThreadExample.java */
public class SimpleThreadExample {

    public static void main(String[] args) {
    
        
        Messages msg = new Messages();
        Thread morningThread = new GreetingsThread(msg, 0);
        Thread afternoonThread = new GreetingsThread(msg, 1);

        morningThread.start();
        afternoonThread.start();
        //MARK
        
    }
}
```
```java
/* Messages.java */
public class Messages {
    public String morning;
    public String afternoon;
    public String evening;
    public String night;

    public Messages() {
      morning = "Good morning!";
      afternoon = "Good afternnon!";
      evening = "Good evening!";
      night = "Good night!";
    }

    public String getMessage(int choice) {
      switch(choice) {
         case 0:
           return this.morning;
         case 1:
           return this.afternoon;
         case 3:
           return this.evening;
         case 4:
           return this.night;
         default:
           return "";        
      }
    }
}
```
```java
/* GreetingsThread.java */
public class GreetingsThread extends Thread {

    private Messages msg;
    private int choice;
    public GreetingsThread(Messages msg, int choice) {
        this.msg = msg;
        this.choice = choice;
    }

    public void run() {
        System.out.println("Started the " + msg.getMessage(choice) + " thread...");
            
        //print 10 times
        for (int i = 0; i < 10; i++) {
            System.out.println(msg.getMessage(choice));
        }

        System.out.println("Exiting the " + msg.getMessage(choice) + " thread...");
    }
}
```
Then:

Run the program a few times. Describe the output of this program. Is it consistent?
Draw a memory diagram of the program at MARK

It is **not** consistent! The order seems to be random.

2) Now let’s modify GreetingsThread to add a Thread.sleep() in the run() method. Recompile the GreatingThread class as below.

Run the program multiple times. Does the output change in any way? Does one thread always finish first, or does the order change?

The main change that I can percieve is the slow crawl of certain processes finishing their thread, the order seems to be more split rather than one finishing completely in front of the other.

/* GreetingsThread.java */
public class GreetingsThread extends Thread {
    private Messages msg;
    private int choice;

    public GreetingsThread(Messages msg, int choice) {
        this.msg = msg;
        this.choice = choice;
    }

    public void run() {
        System.out.println("Started the " + msg.getMessage(choice) + " thread...");

        for (int i = 0; i < 10; i++) {
            System.out.println(msg.getMessage(choice));

            try {
                // Sleep for 1 second (1000 milliseconds)
                Thread.sleep(1000); 
            } catch (InterruptedException e) {
                System.out.println("Interrupted while sleeping...");
            }
        }

        System.out.println("Exiting the " + msg.getMessage(choice) + " thread...");
    }
}

3) Now let’s add a System.out.println() at the end of the main method. Recompile the program with this addition, continuing from above. Explain how it is possible that the main method is complete but the program is still producing output.

```java
/* SimpleThreadExample.java */
public class SimpleThreadExample {
    public static void main(String[] args) {
            
        Messages msg = new Messages();
        Thread morningThread = new GreetingsThread(msg, 0);
        Thread afternoonThread = new GreetingsThread(msg, 1);

        morningThread.start();
        afternoonThread.start();

        System.out.println("Main method exiting...");
    }
}
```

It's possible because the parent thread is still taking place and finishing it's processes, there is no interference from the children towards the parents thread.

4) Finally let’s add a thread.join() to join the morningThread for 5 seconds before starting the afternoonThread. Recompile and rerun. Then describe the output of this program. Explain how attempting to join the first thread for 5 seconds affects the output of this program.

```java
/* SimpleThreadExample.java */
public class SimpleThreadExample {
    public static void main(String[] args) {
        Messages msg = new Messages();
        Thread morningThread = new GreetingsThread(msg, 0);
        Thread afternoonThread = new GreetingsThread(msg, 1);

        morningThread.start();

        try {
            System.out.println("Joining the morning thread for 5 seconds...");
            morningThread.join(5000);
        } catch (InterruptedException e) {
            System.out.println("Interrupted while joining a thread...");
        }

        afternoonThread.start();

        System.out.println("Main method exiting...");
    }
}
```

Only one thread runs at a time now, and we can see the direct difference between their outputs, as the print statements are completely seperated by the exiting message.

5) What does join() do compared to join(10)?
Join() is used for waiting until the thread being specified is **fully** complete, whereas Join(int) is used for waiting for the specified milliseconds amount of time.

6) What is the difference between isAlive() and join()? (note, no arguments to join.)
   
